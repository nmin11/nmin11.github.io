<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on ロコ</title>
    <link>https://nmin11.github.io/jp/tags/java/</link>
    <description>Recent content in Java on ロコ</description>
    <generator>Hugo</generator>
    <language>jp</language>
    <lastBuildDate>Wed, 10 Dec 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://nmin11.github.io/jp/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java並行性を振り返る</title>
      <link>https://nmin11.github.io/jp/blog/6-look-back-at-java-concurrency/</link>
      <pubDate>Wed, 10 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://nmin11.github.io/jp/blog/6-look-back-at-java-concurrency/</guid>
      <description>&lt;h2 id=&#34;0-序論&#34;&gt;0. 序論&lt;/h2&gt;&#xA;&lt;p&gt;恥ずかしながら今年、バックエンドブートキャンプ課程を修了しながら**「並行性」**というキーワードを初めて接した。&#xA;実はブートキャンプを修了する過程で様々なLock方式を実習しながら並行性を制御する方法は十分に習得できた。&#xA;しかし問題を解決する方法だけに集中するよりは「並行性」について本質的な理解をしてから進むべきだと思った。そうすれば今後もバックエンド開発者としての専門的な視野を持てるはずだ。&#xA;そこで並行性プログラミングとは何か、またJava陣営で並行性を扱う方法がどのように発展してきたかを見てみることにした。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-the-free-lunch-is-over2004&#34;&gt;1. The Free Lunch Is Over（2004）&lt;/h2&gt;&#xA;&lt;p&gt;2004年12月、Microsoftの開発者だったHerb Sutterという方が&lt;a href=&#34;http://www.gotw.ca/publications/concurrency-ddj.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Free Lunch Is Over&lt;/a&gt;&#xA;という記事を発表した。&#xA;この記事は以下の強烈なスローガンとともに始まる。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;The biggest sea change in software development since the OO revolution is knocking at the door, and its name is &lt;strong&gt;Concurrency&lt;/strong&gt;.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;オブジェクト指向革命以来最大の変化の波がソフトウェア開発の扉を叩いている。それは&lt;strong&gt;並行性&lt;/strong&gt;だ。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;Herb Sutterは1965年に「半導体に集積されるトランジスタの数が毎年2倍に増加する」と主張した&lt;em&gt;ムーアの法則&lt;/em&gt;が徐々に限界に達していると説明する。&#xA;2001年8月にIntelチップのCPUクロック速度は2GHzだったが、この記事が発表された2004年12月にも4GHzの速度を持つCPUは登場していなかったと述べている。&#xA;実際4GHzのクロック速度はそう遠くない将来に達成できそうに見えるが、果たして10GHzのクロック速度を達成できるだろうか？&#xA;残念ながら限られた半導体容積内に過度に多くのトランジスタを集積すると発熱、消費電力、電流リークの問題が発生するため、より高いクロック速度を達成することはますます難しくなる。&#xA;そのため2025年現在でも高性能CPUが出せる最大クロック速度は6GHz程度のレベルにとどまっている。&lt;/p&gt;&#xA;&lt;p&gt;これに対しHerb Sutterは、開発者が毎年コンピューターのアップグレード要請だけすれば自動的に性能を引き上げられた**「タダ飯」**がすでに1〜2年前に終わったと述べ、現代のアプリケーションの幾何級数的に高まるCPU処理量に備えるために並行性プログラミングがますます重要になると強調する。&#xA;またJavaのようなプログラミング言語レベルでも並行性プログラミングモデルが切実に必要だと言及する。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-jsr-1331662004&#34;&gt;2. JSR-133/166（2004）&lt;/h2&gt;&#xA;&lt;p&gt;このような流れに合わせてJCP（Java Community Process）は2004年にJSR（Java Specification Request）133および166を承認する。&#xA;上記2つのスペックを通じてJava言語は並行性プログラミングを実行できる言語として確固たる地位を築いた。&#xA;どのような変更があったか簡潔に見てみよう。&lt;/p&gt;&#xA;&lt;h3 id=&#34;jsr-133&#34;&gt;JSR-133&lt;/h3&gt;&#xA;&lt;p&gt;実はJava言語は1.0の時からJMM（Java Memory Model）を通じてマルチスレッドを扱うことができた。&#xA;しかし&lt;code&gt;final&lt;/code&gt;フィールドの値を変更できたり、同期化のための再配列を許可しないなど深刻な欠陥が存在した。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;再配列&lt;/strong&gt;：コンパイラ、JIT、キャッシュなど様々な要因により演算の順序はコード上の流れと異なることがあるが、同期化作業を行うにはコンパイラ、ランタイム、ハードウェアはまるで直列実行されるように共謀（協力）しなければならず、この過程を「再配列」と呼ぶ&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;そのためJSR-133はJMMの欠陥を改善し、&lt;code&gt;volatile&lt;/code&gt;、&lt;code&gt;synchronized&lt;/code&gt;、&lt;code&gt;final&lt;/code&gt;キーワードが直感的に動作することを核心目標として進められた。&#xA;開発者がマルチスレッドプログラムがどのようにメモリと相互作用するか自信を持って推論できるよう助け、様々な有名アーキテクチャを正確性と高性能を兼ね備えて実装できるよう提供しようとした。&#xA;概略的な改善事項は以下の通り。&lt;/p&gt;</description>
    </item>
    <item>
      <title>主要なGCアルゴリズム</title>
      <link>https://nmin11.github.io/jp/blog/4-major-gc-algorithms/</link>
      <pubDate>Thu, 14 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://nmin11.github.io/jp/blog/4-major-gc-algorithms/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;『Java最適化』スタディをしながら主要なGCアルゴリズムについてより深く勉強するために書いた記事です。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;serial-gc&#34;&gt;Serial GC&lt;/h2&gt;&#xA;&lt;img src=&#34;https://github.com/nmin11/blog/assets/75058239/2a864abb-d0f9-4371-a7ea-e86db324af71&#34; width=300&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最も単純なGC実装&lt;/li&gt;&#xA;&lt;li&gt;STW（Stop-The-World）後、1つのスレッドでのみGCを実行&lt;/li&gt;&#xA;&lt;li&gt;mark-sweep-compactアルゴリズムを使用&lt;/li&gt;&#xA;&lt;li&gt;マルチスレッド環境には不適切&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;❖ Serial GC有効化フラグ&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;java -XX:+UseSerialGC&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;parallel-gc&#34;&gt;Parallel GC&lt;/h2&gt;&#xA;&lt;img src=&#34;https://github.com/nmin11/blog/assets/75058239/fbf491b0-e50e-4c8d-91c1-2908a363b0d1&#34; width=400&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java 5〜8までのデフォルトGC&lt;/li&gt;&#xA;&lt;li&gt;GC処理率を最大化するため&lt;em&gt;Throughput Collector&lt;/em&gt;とも呼ばれる&lt;/li&gt;&#xA;&lt;li&gt;メモリ空間が十分でコア数が多い場合に有利なアルゴリズム&lt;/li&gt;&#xA;&lt;li&gt;フラグを通じてGCに使用する最大スレッド数、最大停止時間、GC実行時間比率を設定可能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;-XX:ParallelGCThreads=&amp;lt;N&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-XX:MaxGCPauseMillis=&amp;lt;N&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-XX:GCTimeRatio=&amp;lt;N&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;❖ Parallel GC有効化フラグ&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;java -XX:+UseParallelGC&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;parallel-old-gc&#34;&gt;Parallel Old GC&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Parallel GCのOld領域バージョン&lt;/li&gt;&#xA;&lt;li&gt;Old領域までマルチスレッドでGCを実行&lt;/li&gt;&#xA;&lt;li&gt;Old領域に対して&lt;em&gt;Mark-Summary-Compact&lt;/em&gt;アルゴリズムを使用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Markフェーズ：Old領域をリージョン別に分け、リージョン別に頻繁に参照されるオブジェクトをマーキング&lt;/li&gt;&#xA;&lt;li&gt;Summaryフェーズ：生き残ったオブジェクトの中で密度が高い部分がどこか&lt;strong&gt;dense prefix&lt;/strong&gt;を決め、これを基準にcompact領域を減らす&lt;/li&gt;&#xA;&lt;li&gt;Compactフェーズ：compact領域をdestinationとsourceに分け、生き残ったオブジェクトをdestinationに移動し、参照されていないオブジェクトは削除&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;❖ Parallel Old GC有効化フラグ&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;java -XX:+UseParallelOldGC&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;cms-gc&#34;&gt;CMS GC&lt;/h2&gt;&#xA;&lt;p&gt;&lt;em&gt;Concurrent Mark Sweep&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/nmin11/TIL/assets/75058239/ae758bfe-404e-4b03-ba4a-f5a0cf2384f5&#34; alt=&#34;cms-gc&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;❖ Concurrentが付くとアプリケーション動作中に同時に実行されるという意味&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Initial Markフェーズ：クラスローダーから最も近いオブジェクトの中で生きているオブジェクトだけを見つけて終了&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;Concurrent&lt;/em&gt; Markフェーズ：生きていると確認したオブジェクトをルートとして参照されるオブジェクトをマーキング&lt;/li&gt;&#xA;&lt;li&gt;Remarkフェーズ：Concurrent Markフェーズで新しく追加されたり参照が切れたオブジェクトをマーキング&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;Concurrent&lt;/em&gt; Sweepフェーズ：マーキングされていないオブジェクトを削除&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;長所&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;STW時間が非常に短い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Low Latency GCとも呼ばれる&lt;/li&gt;&#xA;&lt;li&gt;低い応答速度が重要な場合に使用される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;短所&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
