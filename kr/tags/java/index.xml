<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 로코</title>
    <link>https://nmin11.github.io/kr/tags/java/</link>
    <description>Recent content in Java on 로코</description>
    <generator>Hugo</generator>
    <language>kr</language>
    <lastBuildDate>Wed, 10 Dec 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://nmin11.github.io/kr/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java 동시성 되짚어보기</title>
      <link>https://nmin11.github.io/kr/blog/6-look-back-at-java-concurrency/</link>
      <pubDate>Wed, 10 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://nmin11.github.io/kr/blog/6-look-back-at-java-concurrency/</guid>
      <description>&lt;h2 id=&#34;0-서론&#34;&gt;0. 서론&lt;/h2&gt;&#xA;&lt;p&gt;부끄럽게도 이번 해에 백엔드 부트캠프 과정을 수료하면서 &lt;strong&gt;&amp;ldquo;동시성&amp;rdquo;&lt;/strong&gt; 이라는 키워드를 처음 접해봤다.&lt;br&gt;&#xA;사실 부트캠프를 수료하는 과정에서 다양한 Lock 방식을 실습해보면서 동시성을 제어하는 방법은 충분히 숙지할 수 있었다.&lt;br&gt;&#xA;하지만 문제를 해결하는 방법에만 집중하기 보다는 &amp;ldquo;동시성&amp;quot;에 대해 본질적인 이해를 하고 넘어가야 앞으로도 백엔드 개발자로서의 전문적인 시야를 갖출 수 있겠다는 생각이 들었다.&lt;br&gt;&#xA;따라서 동시성 프로그래밍이라는 것이 무엇인지, 또 Java 진영에서 동시성을 다루는 방법들이 어떻게 발전해왔는지를 살펴보기로 했다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-the-free-lunch-is-over-2004&#34;&gt;1. The Free Lunch Is Over (2004)&lt;/h2&gt;&#xA;&lt;p&gt;2004년 12월, Microsoft의 개발자였던 Herb Sutter라는 분이 &lt;a href=&#34;http://www.gotw.ca/publications/concurrency-ddj.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Free Lunch Is Over&lt;/a&gt;&#xA;라는 글을 발표했다.&lt;br&gt;&#xA;이 글은 아래의 강렬한 표어와 함께 시작된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>주요 GC 알고리즘들</title>
      <link>https://nmin11.github.io/kr/blog/4-major-gc-algorithms/</link>
      <pubDate>Thu, 14 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://nmin11.github.io/kr/blog/4-major-gc-algorithms/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;『자바 최적화』 스터디를 하면서 주요 GC 알고리즘들에 대해 더 깊이 공부하고자 작성한 글입니다.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;serial-gc&#34;&gt;Serial GC&lt;/h2&gt;&#xA;&lt;img src=&#34;https://github.com/nmin11/blog/assets/75058239/2a864abb-d0f9-4371-a7ea-e86db324af71&#34; width=300&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;가장 단순한 GC 구현체&lt;/li&gt;&#xA;&lt;li&gt;STW(Stop-The-World) 이후 한 개의 스레드에서만 GC 수행&lt;/li&gt;&#xA;&lt;li&gt;mark-sweep-compact 알고리즘 사용&lt;/li&gt;&#xA;&lt;li&gt;멀티 스레드 환경에서는 부적합&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;❖ Serial GC 활성화 플래그&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;java -XX:+UseSerialGC&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;parallel-gc&#34;&gt;Parallel GC&lt;/h2&gt;&#xA;&lt;img src=&#34;https://github.com/nmin11/blog/assets/75058239/fbf491b0-e50e-4c8d-91c1-2908a363b0d1&#34; width=400&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;자바 5 ~ 8까지 디폴트 GC&lt;/li&gt;&#xA;&lt;li&gt;GC 처리율을 최대화하기 때문에 &lt;em&gt;Throughput Collector&lt;/em&gt; 라고도 불림&lt;/li&gt;&#xA;&lt;li&gt;메모리 공간이 충분하고 코어 개수가 많을 때 유리한 알고리즘&lt;/li&gt;&#xA;&lt;li&gt;플래그를 통해 GC에 사용할 최대 스레드 수, 최대 중단 시간, GC 수행 시간 비율을 설정할 수 있음&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;-XX:ParallelGCThreads=&amp;lt;N&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-XX:MaxGCPauseMillis=&amp;lt;N&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-XX:GCTimeRatio=&amp;lt;N&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;❖ Parallel GC 활성화 플래그&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
